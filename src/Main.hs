{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# OPTIONS_GHC -w #-}

module Main (main) where

import           Control.Monad.State.Lazy
import           Data.Bits ((.|.))
import qualified Data.ByteString as B
import           Data.ByteString.Builder
import           Data.Int (Int8, Int16, Int32)
import           Data.List (foldl1')
import           Data.Map.Lazy (Map)
import qualified Data.Map.Lazy as M
import           Data.Monoid ((<>), mconcat)
import           Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import           Data.Word (Word8, Word16)
import           System.IO (IOMode(..), withFile)

------------------------------------------------------------------------

main :: IO ()
main = do
    withFile "examples/Jvmc.class" WriteMode $ \h ->
        hPutBuilder h (bClass jvmc)

jvmc :: Class
jvmc = Class
    { cAccess     = [C'Public, C'Final, C'Super]
    , cName       = ClassRef "Jvmc"
    , cSuper      = ClassRef "java/lang/Object"
    , cInterfaces = []
    , cFields     = []
    , cMethods    = [Method [M'Public, M'Static] "main" (Type "([Ljava/lang/String;)I")]
    , cAttributes = []
    }

------------------------------------------------------------------------

data Class = Class
    { cAccess     :: [ClassAccess]
    , cName       :: ClassRef
    , cSuper      :: ClassRef
    , cInterfaces :: [()]
    , cFields     :: [()]
    , cMethods    :: [Method]
    , cAttributes :: [()]
    } deriving (Eq, Ord, Show, Read)

newtype ClassRef = ClassRef { unClassRef :: Text }
    deriving (Eq, Ord, Show, Read)

data ClassAccess =
      C'Public     -- ^ Declared public; may be accessed from outside its package.
    | C'Final      -- ^ Declared final; no subclasses allowed.
    | C'Super      -- ^ Treat superclass methods specially when invoked by the invokespecial instruction.
    | C'Interface  -- ^ Is an interface, not a class.
    | C'Abstract   -- ^ Declared abstract; must not be instantiated.
    | C'Synthetic  -- ^ Declared synthetic; not present in the source code.
    | C'Annotation -- ^ Declared as an annotation type.
    | C'Enum       -- ^ Declared as an enum type.
    deriving (Eq, Ord, Show, Read)

------------------------------------------------------------------------

data Method = Method
    { mAccess :: [MethodAccess]
    , mName   :: Text
    , mType   :: Type
    } deriving (Eq, Ord, Show, Read)

newtype Type = Type { unType :: Text }
    deriving (Eq, Ord, Show, Read)

data MethodAccess =
      M'Public       -- ^ Declared public; may be accessed from outside its package.
    | M'Private      -- ^ Declared private; accessible only within the defining class.
    | M'Protected    -- ^ Declared protected; may be accessed within subclasses.
    | M'Static       -- ^ Declared static.
    | M'Final        -- ^ Declared final; must not be overridden (ยง5.4.5).
    | M'Synchronized -- ^ Declared synchronized; invocation is wrapped by a monitor use.
    | M'Bridge       -- ^ a Bridge method, generated by the compiler.
    | M'VarArgs      -- ^ Declared with variable number of arguments.
    | M'Native       -- ^ Declared native; implemented in a language other than Java.
    | M'Abstract     -- ^ Declared abstract; no implementation is provided.
    | M'Strict       -- ^ Declared strictfp; floating-point mode is FP-strict.
    | M'Synthetic    -- ^ Declared synthetic; not present in the source code.
    deriving (Eq, Ord, Show, Read)

------------------------------------------------------------------------
-- Constant Pool

data ConstPool = ConstPool
    { cpNext    :: ConstRef
    , cpValues  :: [ConstVal]
    , cpUtf8s   :: Map Text     ConstRef
    , cpClasses :: Map ClassRef ConstRef
    } deriving (Eq, Ord, Show, Read)

newtype ConstRef = ConstRef { unConstRef :: Word16 }
    deriving (Eq, Ord, Show, Read, Enum)

data ConstVal =
      ConstClass ConstRef
    | ConstUtf8  Text
    deriving (Eq, Ord, Show, Read)

emptyConstPool :: ConstPool
emptyConstPool = ConstPool (ConstRef 1) [] M.empty M.empty

------------------------------------------------------------------------

newtype CP a = CP { unCP :: State ConstPool a }
  deriving (Functor, Monad, MonadState ConstPool)

runCP :: CP a -> (a, ConstPool)
runCP m = runState (unCP m) emptyConstPool

------------------------------------------------------------------------

-- TODO: Lenses

addUtf8Ref :: Text -> CP ConstRef
addUtf8Ref utf8 = do
    m <- gets (M.lookup utf8 . cpUtf8s)
    case m of
      Just x  -> return x
      Nothing -> do
        ref <- state (insertVal (ConstUtf8 utf8))
        modify (\cp -> cp { cpUtf8s = M.insert utf8 ref (cpUtf8s cp) })
        return ref

addClassRef :: ClassRef -> CP ConstRef
addClassRef cls@(ClassRef name) = do
    m <- gets (M.lookup cls . cpClasses)
    case m of
      Just x  -> return x
      Nothing -> do
        uref <- addUtf8Ref name
        cref <- state (insertVal (ConstClass uref))
        modify (\cp -> cp { cpClasses = M.insert cls cref (cpClasses cp) })
        return cref

insertVal :: ConstVal -> ConstPool -> (ConstRef, ConstPool)
insertVal val cp@ConstPool{..} =
    (cpNext, cp { cpNext = succ cpNext, cpValues = val : cpValues })

------------------------------------------------------------------------

bClass :: Class -> Builder
bClass Class{..} = bClassHeader
                <> bConstPool cp
                <> b
  where
    (b, cp) = runCP $ do
        this  <- addClassRef cName
        super <- addClassRef cSuper
        ms    <- bMethods cMethods
        return $ bClassAccess cAccess
              <> bConstRef this
              <> bConstRef super
              <> word16BE (fromIntegral (length cInterfaces))
              <> word16BE (fromIntegral (length cFields))
              <> ms
              <> word16BE (fromIntegral (length cAttributes))

bMethods :: [Method] -> CP Builder
bMethods ms = do
    bss <- mapM bMethod ms
    return $ word16BE n
          <> mconcat bss
          <> word16BE 0 -- attributes
  where
    n = fromIntegral (length ms)

bMethod :: Method -> CP Builder
bMethod Method{..} = do
    name <- addUtf8Ref mName
    typ  <- addUtf8Ref (unType mType)
    return $ bMethodAccess mAccess
          <> bConstRef name
          <> bConstRef typ

bClassHeader :: Builder
bClassHeader = word32BE magic <> word16BE minor <> word16BE major
  where
    magic = 0xCAFEBABE
    major = 51
    minor = 0

bConstPool :: ConstPool -> Builder
bConstPool ConstPool{..} = word16BE cpCount
                        <> mconcat (map go (reverse cpValues))
  where
    cpCount = fromIntegral (length cpValues) + 1

    go (ConstClass ref) = word8 7 <> bConstRef ref
    go (ConstUtf8 txt)  = word8 1 <> word16BE n <> byteString bs
      where
        bs = T.encodeUtf8 txt
        n  = fromIntegral (B.length bs)

bConstRef :: ConstRef -> Builder
bConstRef = word16BE . unConstRef

bClassAccess :: [ClassAccess] -> Builder
bClassAccess = word16BE . foldl1' (.|.) . map go
  where
    go C'Public     = 0x1
    go C'Final      = 0x10
    go C'Super      = 0x20
    go C'Interface  = 0x200
    go C'Abstract   = 0x400
    go C'Synthetic  = 0x1000
    go C'Annotation = 0x2000
    go C'Enum       = 0x4000

bMethodAccess :: [MethodAccess] -> Builder
bMethodAccess = word16BE . foldl1' (.|.) . map go
  where
    go M'Public       = 0x1
    go M'Private      = 0x2
    go M'Protected    = 0x4
    go M'Static       = 0x8
    go M'Final        = 0x10
    go M'Synchronized = 0x20
    go M'Bridge       = 0x40
    go M'VarArgs      = 0x80
    go M'Native       = 0x100
    go M'Abstract     = 0x400
    go M'Strict       = 0x800
    go M'Synthetic    = 0x1000

------------------------------------------------------------------------

data Instruction =
      NOp                   -- ^ 0x00 - perform no operation

    | AConst_null           -- ^ 0x01 - push a null reference onto the stack
    | IConst_m1             -- ^ 0x02 - load the int value -1 onto the stack
    | IConst_0              -- ^ 0x03 - load the int value 0 onto the stack
    | IConst_1              -- ^ 0x04 - load the int value 1 onto the stack
    | IConst_2              -- ^ 0x05 - load the int value 2 onto the stack
    | IConst_3              -- ^ 0x06 - load the int value 3 onto the stack
    | IConst_4              -- ^ 0x07 - load the int value 4 onto the stack
    | IConst_5              -- ^ 0x08 - load the int value 5 onto the stack
    | LConst_0              -- ^ 0x09 - push the long 0 onto the stack
    | LConst_1              -- ^ 0x0a - push the long 1 onto the stack
    | FConst_0              -- ^ 0x0b - push 0.0f on the stack
    | FConst_1              -- ^ 0x0c - push 1.0f on the stack
    | FConst_2              -- ^ 0x0d - push 2.0f on the stack
    | DConst_0              -- ^ 0x0e - push the constant 0.0 onto the stack
    | DConst_1              -- ^ 0x0f - push the constant 1.0 onto the stack

    | BIPush Int8           -- ^ 0x10 - push a byte onto the stack as an integer value
    | SIPush Int16          -- ^ 0x11 - push a short onto the stack

    | LDC    Word8          -- ^ 0x12 - push a constant #index from a constant pool (String, int or float) onto the stack
    | LDC_W  Word16         -- ^ 0x13 - push a constant #index from a constant pool (String, int or float) onto the stack
                            --            (wide index is constructed as indexbyte1 << 8 + indexbyte2)
    | LDC2_W Word16         -- ^ 0x14 - push a constant #index from a constant pool (double or long) onto the stack
                            --            (wide index is constructed as indexbyte1 << 8 + indexbyte2)

    | ILoad Word8           -- ^ 0x15 - load an int value from a local variable #index
    | LLoad Word8           -- ^ 0x16 - load a long value from a local variable #index
    | FLoad Word8           -- ^ 0x17 - load a float value from a local variable #index
    | DLoad Word8           -- ^ 0x18 - load a double value from a local variable #index
    | ALoad Word8           -- ^ 0x19 - load a reference onto the stack from a local variable #index

    | ILoad_0               -- ^ 0x1a - load an int value from local variable 0
    | ILoad_1               -- ^ 0x1b - load an int value from local variable 1
    | ILoad_2               -- ^ 0x1c - load an int value from local variable 2
    | ILoad_3               -- ^ 0x1d - load an int value from local variable 3

    | LLoad_0               -- ^ 0x1e - load a long value from a local variable 0
    | LLoad_1               -- ^ 0x1f - load a long value from a local variable 1
    | LLoad_2               -- ^ 0x20 - load a long value from a local variable 2
    | LLoad_3               -- ^ 0x21 - load a long value from a local variable 3

    | FLoad_0               -- ^ 0x22 - load a float value from local variable 0
    | FLoad_1               -- ^ 0x23 - load a float value from local variable 1
    | FLoad_2               -- ^ 0x24 - load a float value from local variable 2
    | FLoad_3               -- ^ 0x25 - load a float value from local variable 3

    | DLoad_0               -- ^ 0x26 - load a double from local variable 0
    | DLoad_1               -- ^ 0x27 - load a double from local variable 1
    | DLoad_2               -- ^ 0x28 - load a double from local variable 2
    | DLoad_3               -- ^ 0x29 - load a double from local variable 3

    | ALoad_0               -- ^ 0x2a - load a reference onto the stack from local variable 0
    | ALoad_1               -- ^ 0x2b - load a reference onto the stack from local variable 1
    | ALoad_2               -- ^ 0x2c - load a reference onto the stack from local variable 2
    | ALoad_3               -- ^ 0x2d - load a reference onto the stack from local variable 3

    | IALoad                -- ^ 0x2e - load an int from an array
    | LALoad                -- ^ 0x2f - load a long from an array
    | FALoad                -- ^ 0x30 - load a float from an array
    | DALoad                -- ^ 0x31 - load a double from an array
    | AALoad                -- ^ 0x32 - load onto the stack a reference from an array
    | BALoad                -- ^ 0x33 - load a byte or Boolean value from an array
    | CALoad                -- ^ 0x34 - load a char from an array
    | SALoad                -- ^ 0x35 - load a short from an array

    | IStore Word8          -- ^ 0x36 - store int value into variable #index
    | LStore Word8          -- ^ 0x37 - store a long value in a local variable #index
    | FStore Word8          -- ^ 0x38 - store a float value into a local variable #index
    | DStore Word8          -- ^ 0x39 - store a double value into a local variable #index
    | AStore Word8          -- ^ 0x3a - store a reference into a local variable #index

    | IStore_0              -- ^ 0x3b - store int value into variable 0
    | IStore_1              -- ^ 0x3c - store int value into variable 1
    | IStore_2              -- ^ 0x3d - store int value into variable 2
    | IStore_3              -- ^ 0x3e - store int value into variable 3

    | LStore_0              -- ^ 0x3f - store a long value in a local variable 0
    | LStore_1              -- ^ 0x40 - store a long value in a local variable 1
    | LStore_2              -- ^ 0x41 - store a long value in a local variable 2
    | LStore_3              -- ^ 0x42 - store a long value in a local variable 3

    | FStore_0              -- ^ 0x43 - store a float value into local variable 0
    | FStore_1              -- ^ 0x44 - store a float value into local variable 1
    | FStore_2              -- ^ 0x45 - store a float value into local variable 2
    | FStore_3              -- ^ 0x46 - store a float value into local variable 3

    | DStore_0              -- ^ 0x47 - store a double into local variable 0
    | DStore_1              -- ^ 0x48 - store a double into local variable 1
    | DStore_2              -- ^ 0x49 - store a double into local variable 2
    | DStore_3              -- ^ 0x4a - store a double into local variable 3

    | AStore_0              -- ^ 0x4b - store a reference into local variable 0
    | AStore_1              -- ^ 0x4c - store a reference into local variable 1
    | AStore_2              -- ^ 0x4d - store a reference into local variable 2
    | AStore_3              -- ^ 0x4e - store a reference into local variable 3

    | IAStore               -- ^ 0x4f - store an int in an array
    | LAStore               -- ^ 0x50 - store a long to an array
    | FAStore               -- ^ 0x51 - store a float in an array
    | DAStore               -- ^ 0x52 - store a double in an array
    | AAStore               -- ^ 0x53 - store a reference in an array
    | BAStore               -- ^ 0x54 - store a byte or Boolean value in an array
    | CAStore               -- ^ 0x55 - store a char intan array
    | SAStore               -- ^ 0x56 - store a short in an array

    | Pop                   -- ^ 0x57 - discard the top value on the stack
    | Pop2                  -- ^ 0x58 - discard the top two values on the stack
                            --            (or one value, if it is a double or long)

    | Dup                   -- ^ 0x59 - duplicate the value on top of the stack
    | Dup_x1                -- ^ 0x5a - insert a copy of the top value into the stack two values from the top.
                            --            (value1 and value2 must not be of the type double or long)
    | Dup_x2                -- ^ 0x5b - insert a copy of the top value into the stack two
                            --            (if value2 is double or long it takes up the entry of value3, too)
                            --          or three values
                            --            (if value2 is neither double nor long)
                            --          from the top

    | Dup2                  -- ^ 0x5c - duplicate top two stack words
                            --            (two values, if value1 is not double nor long;
                            --             a single value, if value1 is double or long)
    | Dup2_x1               -- ^ 0x5d - duplicate two words and insert beneath third word (see explanation above)
    | Dup2_x2               -- ^ 0x5e - duplicate two words and insert beneath fourth word

    | Swap                  -- ^ 0x5f - swaps two top words on the stack
                            --            (note that value1 and value2 must not be double or long)

    | IAdd                  -- ^ 0x60 - add two ints
    | LAdd                  -- ^ 0x61 - add two longs
    | FAdd                  -- ^ 0x62 - add two floats
    | DAdd                  -- ^ 0x63 - add two doubles

    | ISub                  -- ^ 0x64 - subtract two ints
    | LSub                  -- ^ 0x65 - subtract two longs
    | FSub                  -- ^ 0x66 - subtract two floats
    | DSub                  -- ^ 0x67 - subtract two doubles

    | IMul                  -- ^ 0x68 - multiply two integers
    | LMul                  -- ^ 0x69 - multiply two longs
    | FMul                  -- ^ 0x6a - multiply two floats
    | DMul                  -- ^ 0x6b - multiply two doubles

    | IDiv                  -- ^ 0x6c - divide two integers
    | LDiv                  -- ^ 0x6d - divide two longs
    | FDiv                  -- ^ 0x6e - divide two floats
    | DDiv                  -- ^ 0x6f - divide two doubles

    | IRem                  -- ^ 0x70 - remainder of division of two ints
    | LRem                  -- ^ 0x71 - remainder of division of two longs
    | FRem                  -- ^ 0x72 - remainder of division of two floats
    | DRem                  -- ^ 0x73 - remainder of division of two doubles

    | INeg                  -- ^ 0x74 - negate an int
    | LNeg                  -- ^ 0x75 - negate a long
    | FNeg                  -- ^ 0x76 - negate a float
    | DNeg                  -- ^ 0x77 - negate a double

    | IShl                  -- ^ 0x78 - int shift left
    | LShl                  -- ^ 0x79 - bitwise shift left of a long value1 by int value2 positions

    | IShr                  -- ^ 0x7a - int arithmetic shift right
    | LShr                  -- ^ 0x7b - bitwise shift right of a long value1 by int value2 positions

    | IUShr                 -- ^ 0x7c - int logical shift right
    | LUShr                 -- ^ 0x7d - bitwise shift right of a long value1 by int value2 positions, unsigned

    | IAnd                  -- ^ 0x7e - bitwise AND of two ints
    | LAnd                  -- ^ 0x7f - bitwise AND of two longs
    | IOr                   -- ^ 0x80 - bitwise OR of two ints
    | LOr                   -- ^ 0x81 - bitwise OR of two longs
    | IXor                  -- ^ 0x82 - bitwise XOR of two ints
    | LXor                  -- ^ 0x83 - bitwise XOR of two longs

    | IInc Word8 Int8       -- ^ 0x84 - increment local variable #index by signed byte #const

    | I2L                   -- ^ 0x85 - convert an int into a long
    | I2F                   -- ^ 0x86 - convert an int into a float
    | I2D                   -- ^ 0x87 - convert an int into a double

    | L2I                   -- ^ 0x88 - convert a long to a int
    | L2F                   -- ^ 0x89 - convert a long to a float
    | L2D                   -- ^ 0x8a - convert a long to a double

    | F2I                   -- ^ 0x8b - convert a float to an int
    | F2L                   -- ^ 0x8c - convert a float to a long
    | F2D                   -- ^ 0x8d - convert a float to a double

    | D2I                   -- ^ 0x8e - convert a double to an int
    | D2L                   -- ^ 0x8f - convert a double to a long
    | D2F                   -- ^ 0x90 - convert a double to a float

    | I2B                   -- ^ 0x91 - convert an int into a byte
    | I2C                   -- ^ 0x92 - convert an int into a character
    | I2S                   -- ^ 0x93 - convert an int into a short

    | LCmp                  -- ^ 0x94 - compare two longs values
    | FCmpL                 -- ^ 0x95 - compare two floats
    | FCmpG                 -- ^ 0x96 - compare two floats
    | DCmpL                 -- ^ 0x97 - compare two doubles
    | DCmpG                 -- ^ 0x98 - compare two doubles

    | IfEq Int16            -- ^ 0x99 - if value is 0, branch to instruction at #branchoffset
    | IfNe Int16            -- ^ 0x9a - if value is not 0, branch to instruction at #branchoffset
    | IfLt Int16            -- ^ 0x9b - if value is less than 0, branch to instruction at #branchoffset
    | IfGe Int16            -- ^ 0x9c - if value is greater than or equal to 0, branch to instruction at #branchoffset
    | IfGt Int16            -- ^ 0x9d - if value is greater than 0, branch to instruction at #branchoffset
    | IfLe Int16            -- ^ 0x9e - if value is less than or equal to 0, branch to instruction at #branchoffset

    | If_ICmpEq Int16       -- ^ 0x9f - if ints are equal, branch to instruction at #branchoffset
    | If_ICmpNe Int16       -- ^ 0xa0 - if ints are not equal, branch to instruction at #branchoffset
    | If_ICmpLt Int16       -- ^ 0xa1 - if value1 is less than value2, branch to instruction at #branchoffset
    | If_ICmpGe Int16       -- ^ 0xa2 - if value1 is greater than or equal to value2, branch to instruction at #branchoffset
    | If_ICmpGt Int16       -- ^ 0xa3 - if value1 is greater than value2, branch to instruction at #branchoffset
    | If_ICmpLe Int16       -- ^ 0xa4 - if value1 is less than or equal to value2, branch to instruction at #branchoffset

    | If_ACmpEq Int16       -- ^ 0xa5 - if references are equal, branch to instruction at #branchoffset
    | If_ACmpNe Int16       -- ^ 0xa6 - if references are not equal, branch to instruction at #branchoffset

    | Goto Int16            -- ^ 0xa7 - goes to another instruction at #branchoffset
    | JSr  Int16            -- ^ 0xa8 - jump to subroutine at #branchoffset and place the return address on the stack
    | Ret  Word8            -- ^ 0xa9 - continue execution from address taken from a local variable #index
                            --            (the asymmetry with jsr is intentional)

    | TableSwitch           -- ^ 0xaa - continue execution from an address in the table at offset index
    | LookupSwitch          -- ^ 0xab - a target address is looked up from a table using a key and execution
                            --            continues from the instruction at that address

    | IReturn               -- ^ 0xac - return an int
    | LReturn               -- ^ 0xad - return a long
    | FReturn               -- ^ 0xae - return a float
    | DReturn               -- ^ 0xaf - return a double
    | AReturn               -- ^ 0xb0 - return a reference
    | Return                -- ^ 0xb1 - return void

    | GetStatic Word16      -- ^ 0xb2 - get static field value of class, where field is identified by #index in constant pool
    | PutStatic Word16      -- ^ 0xb3 - set static field value of class, where field is identified by #index in constant pool

    | GetField  Word16      -- ^ 0xb4 - get field value of object, where the field is identified by #index in constant pool
    | PutField  Word16      -- ^ 0xb5 - set field value of object, where the field is identified by #index in constant pool

    | InvokeVirtual	  Word16        -- ^ 0xb6 - invoke virtual method identified by #index in constant pool
    | InvokeSpecial	  Word16        -- ^ 0xb7 - invoke instance method identified by #index in constant pool
    | InvokeStatic    Word16        -- ^ 0xb8 - invoke static method identified by #index in constant pool
    | InvokeInterface Word16 Word8  -- ^ 0xb9 - invoke interface method identified by #index in constant pool
    | InvokeDynamic   Word16        -- ^ 0xba - invoke dynamic method identified by #index in constant pool

    | New       Word16      -- ^ 0xbb - create new object of type identified by #index in constant pool
    | NewArray  Word8       -- ^ 0xbc - create new array with count elements of primitive type identified by #atype
    | ANewArray Word16      -- ^ 0xbd - create new array with count elements of reference type identified by #index in constant pool

    | ArrayLength           -- ^ 0xbe - get the length of an array

    | AThrow                -- ^ 0xbf - throws an error or exception (the stack is cleared, leaving only the Throwable)

    | CheckCast  Word16     -- ^ 0xc0 - casts an object is to a certain type, identified by #index in constant pool
    | InstanceOf Word16     -- ^ 0xc1 - determines if an object is of a certain type, identified by #index in constant pool

    | MonitorEnter          -- ^ 0xc2 - enter monitor for object ("grab the lock" - start of synchronized() section)
    | MonitorExit           -- ^ 0xc3 - exit monitor for object ("release the lock" - end of synchronized() section)

    | Wide                  -- ^ 0xc4 - wide version of load/store/inc

    | MultiANewArray Word16 Word8   -- ^ 0xc5 - create a new array of #dimensions with elements of type #index in constant pool

    | IfNull    Int16      -- ^ 0xc6 - if value is null, branch to instruction at #branchoffset
    | IfNonNull Int16      -- ^ 0xc7 - if value is not null, branch to instruction at #branchoffset

    | Goto_W Int32         -- ^ 0xc8 - goes to another instruction at #branchoffset
    | JSr_W  Int32         -- ^ 0xc9 - jump to subroutine at #branchoffset
