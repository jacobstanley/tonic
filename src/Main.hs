{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# OPTIONS_GHC -w #-}

module Main (main) where

import           Control.Applicative (Applicative, (<$>), (<*>), pure)
import           Control.Monad.State.Lazy
import           Data.Bits ((.|.))
import qualified Data.ByteString as B
import           Data.ByteString.Builder
import qualified Data.ByteString.Lazy as L
import           Data.Int (Int8, Int16, Int32)
import           Data.List (foldl1')
import           Data.Map.Lazy (Map)
import qualified Data.Map.Lazy as M
import           Data.Maybe (mapMaybe)
import           Data.Monoid ((<>), mconcat, mempty)
import           Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import           Data.Word (Word8, Word16)
import           System.IO (IOMode(..), withFile)

------------------------------------------------------------------------

main :: IO ()
main = do
    withFile "examples/Jvmc.class" WriteMode $ \h ->
        hPutBuilder h (bClass jvmc)

jvmc :: Class
jvmc = Class
    { cAccess     = [C'Public, C'Final, C'Super]
    , cName       = ClassRef "Jvmc"
    , cSuper      = ClassRef "java/lang/Object"
    , cInterfaces = [ClassRef "java/lang/Comparable"]
    , cFields     = [Field [F'Static] "foo" (Type "I")]
    , cMethods    = [Method [M'Public, M'Static] "main" (Type "([Ljava/lang/String;)V") (Just code)]
    , cSourceFile = Just "Jvmc.java"
    }
  where
    code = Code 1 [ GetStatic sysOut
                  , SPush "Hello World!"
                  , InvokeVirtual println
                  , BIPush 42
                  , InvokeStatic sysExit
                  , Return ]

    sysOut  = FieldRef  (ClassRef "java/lang/System")    (NameType "out"     (Type "Ljava/io/PrintStream;"))
    sysExit = MethodRef (ClassRef "java/lang/System")    (NameType "exit"    (Type "(I)V"))
    println = MethodRef (ClassRef "java/io/PrintStream") (NameType "println" (Type "(Ljava/lang/String;)V"))

-- java/io/PrintStream.println : (Ljava/lang/String;)V

------------------------------------------------------------------------

data Class = Class
    { cAccess     :: [ClassAccess]
    , cName       :: ClassRef
    , cSuper      :: ClassRef
    , cInterfaces :: [ClassRef]
    , cFields     :: [Field]
    , cMethods    :: [Method]
    , cSourceFile :: Maybe Text
    } deriving (Eq, Ord, Show, Read)

data ClassAccess =
      C'Public     -- ^ Declared public; may be accessed from outside its package.
    | C'Final      -- ^ Declared final; no subclasses allowed.
    | C'Super      -- ^ Treat superclass methods specially when invoked by the invokespecial instruction.
    | C'Interface  -- ^ Is an interface, not a class.
    | C'Abstract   -- ^ Declared abstract; must not be instantiated.
    | C'Synthetic  -- ^ Declared synthetic; not present in the source code.
    | C'Annotation -- ^ Declared as an annotation type.
    | C'Enum       -- ^ Declared as an enum type.
    deriving (Eq, Ord, Show, Read)

------------------------------------------------------------------------

data Field = Field
    { fAccess :: [FieldAccess]
    , fName   :: Text
    , fType   :: Type
    } deriving (Eq, Ord, Show, Read)

data FieldAccess =
      F'Public    -- ^ Declared public; may be accessed from outside its package.
    | F'Private   -- ^ Declared private; usable only within the defining class.
    | F'Protected -- ^ Declared protected; may be accessed within subclasses.
    | F'Static    -- ^ Declared static.
    | F'Final     -- ^ Declared final; never directly assigned to after object construction (JLS ยง17.5).
    | F'Volatile  -- ^ Declared volatile; cannot be cached.
    | F'Transient -- ^ Declared transient; not written or read by a persistent object manager.
    | F'Synthetic -- ^ Declared synthetic; not present in the source code.
    | F'Enum      -- ^ Declared as an element of an enum.
    deriving (Eq, Ord, Show, Read)

------------------------------------------------------------------------

data Method = Method
    { mAccess :: [MethodAccess]
    , mName   :: Text
    , mType   :: Type
    , mCode   :: Maybe Code
    } deriving (Eq, Ord, Show, Read)

newtype Type = Type { unType :: Text }
    deriving (Eq, Ord, Show, Read)

data MethodAccess =
      M'Public       -- ^ Declared public; may be accessed from outside its package.
    | M'Private      -- ^ Declared private; accessible only within the defining class.
    | M'Protected    -- ^ Declared protected; may be accessed within subclasses.
    | M'Static       -- ^ Declared static.
    | M'Final        -- ^ Declared final; must not be overridden (ยง5.4.5).
    | M'Synchronized -- ^ Declared synchronized; invocation is wrapped by a monitor use.
    | M'Bridge       -- ^ A bridge method, generated by the compiler.
    | M'VarArgs      -- ^ Declared with variable number of arguments.
    | M'Native       -- ^ Declared native; implemented in a language other than Java.
    | M'Abstract     -- ^ Declared abstract; no implementation is provided.
    | M'Strict       -- ^ Declared strictfp; floating-point mode is FP-strict.
    | M'Synthetic    -- ^ Declared synthetic; not present in the source code.
    deriving (Eq, Ord, Show, Read)

------------------------------------------------------------------------

data Code = Code
    { cMaxLocals    :: Word16 -- be calculated
    , cInstructions :: [Instruction]
    } deriving (Eq, Ord, Show, Read)

------------------------------------------------------------------------

newtype ClassRef = ClassRef { unClassRef :: Text }
    deriving (Eq, Ord, Show, Read)

data FieldRef = FieldRef
    { fClass    :: ClassRef
    , fNameType :: NameType
    } deriving (Eq, Ord, Show, Read)

data MethodRef = MethodRef
    { mClass    :: ClassRef
    , mNameType :: NameType
    } deriving (Eq, Ord, Show, Read)

data NameType = NameType
    { nName :: Text
    , nType :: Type
    } deriving (Eq, Ord, Show, Read)

------------------------------------------------------------------------
-- Constant Pool

data ConstPool = ConstPool
    { cpNext      :: ConstRef
    , cpValues    :: [ConstVal]
    , cpUtf8s     :: Map Text      ConstRef
    , cpStrings   :: Map Text      ConstRef
    , cpClasses   :: Map ClassRef  ConstRef
    , cpFields    :: Map FieldRef  ConstRef
    , cpMethods   :: Map MethodRef ConstRef
    , cpNameTypes :: Map NameType  ConstRef
    } deriving (Eq, Ord, Show, Read)

newtype ConstRef = ConstRef { unConstRef :: Word16 }
    deriving (Eq, Ord, Show, Read, Enum)

data ConstVal =
      ConstUtf8     Text
    | ConstString   ConstRef
    | ConstClass    ConstRef
    | ConstField    ConstRef ConstRef
    | ConstMethod   ConstRef ConstRef
    | ConstNameType ConstRef ConstRef
    deriving (Eq, Ord, Show, Read)

emptyConstPool :: ConstPool
emptyConstPool = ConstPool
    (ConstRef 1) [] M.empty M.empty M.empty M.empty M.empty M.empty

------------------------------------------------------------------------

newtype CP a = CP { unCP :: State ConstPool a }
  deriving (Functor, Applicative, Monad, MonadState ConstPool)

runCP :: CP a -> (a, ConstPool)
runCP m = runState (unCP m) emptyConstPool

------------------------------------------------------------------------

-- TODO: Lenses

addUtf8Ref :: Text -> CP ConstRef
addUtf8Ref utf8 = do
    m <- gets (M.lookup utf8 . cpUtf8s)
    case m of
      Just x  -> return x
      Nothing -> do
        ref <- state (insertVal (ConstUtf8 utf8))
        modify (\cp -> cp { cpUtf8s = M.insert utf8 ref (cpUtf8s cp) })
        return ref

addString :: Text -> CP ConstRef
addString str = do
    m <- gets (M.lookup str . cpStrings)
    case m of
      Just x  -> return x
      Nothing -> do
        uref <- addUtf8Ref str
        ref  <- state (insertVal (ConstString uref))
        modify (\cp -> cp { cpStrings = M.insert str ref (cpStrings cp) })
        return ref

addNameType :: NameType -> CP ConstRef
addNameType nt@(NameType name typ) = do
    m <- gets (M.lookup nt . cpNameTypes)
    case m of
      Just x  -> return x
      Nothing -> do
        nref <- addUtf8Ref name
        tref <- addUtf8Ref (unType typ)
        ref  <- state (insertVal (ConstNameType nref tref))
        modify (\cp -> cp { cpNameTypes = M.insert nt ref (cpNameTypes cp) })
        return ref

addMethodRef :: MethodRef -> CP ConstRef
addMethodRef mr@(MethodRef cls nt) = do
    m <- gets (M.lookup mr . cpMethods)
    case m of
      Just x  -> return x
      Nothing -> do
        cref <- addClassRef cls
        nref <- addNameType nt
        ref  <- state (insertVal (ConstMethod cref nref))
        modify (\cp -> cp { cpMethods = M.insert mr ref (cpMethods cp) })
        return ref

addFieldRef :: FieldRef -> CP ConstRef
addFieldRef mr@(FieldRef cls nt) = do
    m <- gets (M.lookup mr . cpFields)
    case m of
      Just x  -> return x
      Nothing -> do
        cref <- addClassRef cls
        nref <- addNameType nt
        ref  <- state (insertVal (ConstField cref nref))
        modify (\cp -> cp { cpFields = M.insert mr ref (cpFields cp) })
        return ref

addClassRef :: ClassRef -> CP ConstRef
addClassRef cls@(ClassRef name) = do
    m <- gets (M.lookup cls . cpClasses)
    case m of
      Just x  -> return x
      Nothing -> do
        uref <- addUtf8Ref name
        cref <- state (insertVal (ConstClass uref))
        modify (\cp -> cp { cpClasses = M.insert cls cref (cpClasses cp) })
        return cref

insertVal :: ConstVal -> ConstPool -> (ConstRef, ConstPool)
insertVal val cp@ConstPool{..} =
    (cpNext, cp { cpNext = succ cpNext, cpValues = val : cpValues })

------------------------------------------------------------------------

bClass :: Class -> Builder
bClass Class{..} = bClassHeader
                <> bConstPool cp
                <> b
  where
    (b, cp) = runCP $ do
        this  <- bClassRef cName
        super <- bClassRef cSuper
        is    <- bInterfaces cInterfaces
        fs    <- bFields cFields
        ms    <- bMethods cMethods
        attrs <- bAttributes [("SourceFile", bUtf8Ref <$> cSourceFile)]
        return $ bClassAccess cAccess
              <> this
              <> super
              <> is <> fs <> ms
              <> attrs

bClassHeader :: Builder
bClassHeader = word32BE magic <> word16BE minor <> word16BE major
  where
    magic = 0xCAFEBABE
    major = 51
    minor = 0

------------------------------------------------------------------------

bConstPool :: ConstPool -> Builder
bConstPool ConstPool{..} = word16BE cpCount
                        <> mconcat (map go (reverse cpValues))
  where
    cpCount = fromIntegral (length cpValues) + 1

    go (ConstUtf8 txt) = word8 1 <> word16BE n <> byteString bs
      where
        bs = T.encodeUtf8 txt
        n  = fromIntegral (B.length bs)

    go (ConstString ref) = word8 8 <> bConstRef ref

    go (ConstClass ref)          = word8 7  <> bConstRef ref
    go (ConstField cref nref)    = word8 9  <> bConstRef cref <> bConstRef nref
    go (ConstMethod cref nref)   = word8 10 <> bConstRef cref <> bConstRef nref
    go (ConstNameType nref tref) = word8 12 <> bConstRef nref <> bConstRef tref

bConstRef :: ConstRef -> Builder
bConstRef = word16BE . unConstRef

bUtf8Ref :: Text -> CP Builder
bUtf8Ref = (bConstRef <$>) . addUtf8Ref

bClassRef :: ClassRef -> CP Builder
bClassRef = (bConstRef <$>) . addClassRef

bFieldRef :: FieldRef -> CP Builder
bFieldRef = (bConstRef <$>) . addFieldRef

bMethodRef :: MethodRef -> CP Builder
bMethodRef = (bConstRef <$>) . addMethodRef

------------------------------------------------------------------------

bInterfaces :: [ClassRef] -> CP Builder
bInterfaces is = do
    refs <- mapM bClassRef is
    return $ word16BE n
          <> mconcat refs
  where
    n = fromIntegral (length is)

------------------------------------------------------------------------

bFields :: [Field] -> CP Builder
bFields fs = do
    bs <- mapM bField fs
    return $ word16BE (fromIntegral (length fs))
          <> mconcat bs

bField :: Field -> CP Builder
bField Field{..} = do
    name <- bUtf8Ref fName
    typ  <- bUtf8Ref (unType fType)
    return $ bFieldAccess fAccess
          <> name
          <> typ
          <> word16BE 0 -- attributes

------------------------------------------------------------------------

bMethods :: [Method] -> CP Builder
bMethods ms = do
    bs <- mapM bMethod ms
    return $ word16BE (fromIntegral (length ms))
          <> mconcat bs

bMethod :: Method -> CP Builder
bMethod Method{..} = do
    name  <- bUtf8Ref mName
    typ   <- bUtf8Ref (unType mType)
    attrs <- bAttributes [("Code", bCode <$> mCode)]
    return $ bMethodAccess mAccess
          <> name
          <> typ
          <> attrs

------------------------------------------------------------------------

bCode :: Code -> CP Builder
bCode Code{..} = do
    lbs <- toLazyByteString . mconcat <$> mapM bInstruction cInstructions
    return $ word16BE maxStack
          <> word16BE cMaxLocals
          <> word32BE (fromIntegral (L.length lbs))
          <> lazyByteString lbs
          <> word16BE 0 -- exception table
          <> word16BE 0 -- attributes
  where
    maxStack = fromIntegral
             . maximum
             . scanl (+) 0
             . map stackDiff
             $ cInstructions

bInstruction :: Instruction -> CP Builder
bInstruction i = case i of
    BIPush x -> pure (word8 0x10 <> int8 x)

    SPush x -> ldc <$> addString x

    IReturn -> pure (word8 0xac)
    LReturn -> pure (word8 0xad)
    FReturn -> pure (word8 0xae)
    DReturn -> pure (word8 0xaf)
    AReturn -> pure (word8 0xb0)
    Return  -> pure (word8 0xb1)

    GetStatic     x -> (word8 0xb2 <>) <$> bFieldRef x
    InvokeVirtual x -> (word8 0xb6 <>) <$> bMethodRef x
    InvokeStatic  x -> (word8 0xb8 <>) <$> bMethodRef x

    x -> error ("bInstruction: Unknown instruction: " <> show x)
  where
    ldc (ConstRef ref) | ref <= max8 = word8 0x12 <> word8 (fromIntegral ref)
                       | otherwise   = word8 0x13 <> word16BE ref

    max8 = fromIntegral (maxBound :: Word8)

stackDiff :: Instruction -> Int
stackDiff i = case i of
    BIPush _ -> 1

    SPush _ -> 1

    IReturn -> -1
    LReturn -> -2
    FReturn -> -1
    DReturn -> -2
    AReturn -> -1
    Return  -> 0

    GetStatic     _ -> 1
    InvokeVirtual _ -> -1 -- need to count params
    InvokeStatic  _ -> 0  -- need to count params

    x -> error ("stackDiff: Unknown instruction: " <> show x)

------------------------------------------------------------------------

bAttributes :: [(Text, Maybe (CP Builder))] -> CP Builder
bAttributes as = do
    bs <- mapM (uncurry bAttribute) as'
    return $ word16BE (fromIntegral (length as))
          <> mconcat bs
  where
    as' = mapMaybe go as

    go (_, Nothing) = Nothing
    go (t, Just b)  = Just (t, b)

bAttribute :: Text -> CP Builder -> CP Builder
bAttribute name b = do
    ref <- addUtf8Ref name
    lbs <- toLazyByteString <$> b
    return $ bConstRef ref
          <> word32BE (fromIntegral (L.length lbs))
          <> lazyByteString lbs

------------------------------------------------------------------------

bClassAccess :: [ClassAccess] -> Builder
bClassAccess = word16BE . foldl1' (.|.) . map go
  where
    go C'Public     = 0x1
    go C'Final      = 0x10
    go C'Super      = 0x20
    go C'Interface  = 0x200
    go C'Abstract   = 0x400
    go C'Synthetic  = 0x1000
    go C'Annotation = 0x2000
    go C'Enum       = 0x4000

bFieldAccess :: [FieldAccess] -> Builder
bFieldAccess = word16BE . foldl1' (.|.) . map go
  where
    go F'Public    = 0x1
    go F'Private   = 0x2
    go F'Protected = 0x4
    go F'Static    = 0x8
    go F'Final     = 0x10
    go F'Volatile  = 0x40
    go F'Transient = 0x80
    go F'Synthetic = 0x1000
    go F'Enum      = 0x4000

bMethodAccess :: [MethodAccess] -> Builder
bMethodAccess = word16BE . foldl1' (.|.) . map go
  where
    go M'Public       = 0x1
    go M'Private      = 0x2
    go M'Protected    = 0x4
    go M'Static       = 0x8
    go M'Final        = 0x10
    go M'Synchronized = 0x20
    go M'Bridge       = 0x40
    go M'VarArgs      = 0x80
    go M'Native       = 0x100
    go M'Abstract     = 0x400
    go M'Strict       = 0x800
    go M'Synthetic    = 0x1000

------------------------------------------------------------------------

data Instruction =
      NOp                   -- ^ 0x00 - perform no operation

    | AConst_null           -- ^ 0x01 - push a null reference onto the stack
    | IConst_m1             -- ^ 0x02 - load the int value -1 onto the stack
    | IConst_0              -- ^ 0x03 - load the int value 0 onto the stack
    | IConst_1              -- ^ 0x04 - load the int value 1 onto the stack
    | IConst_2              -- ^ 0x05 - load the int value 2 onto the stack
    | IConst_3              -- ^ 0x06 - load the int value 3 onto the stack
    | IConst_4              -- ^ 0x07 - load the int value 4 onto the stack
    | IConst_5              -- ^ 0x08 - load the int value 5 onto the stack
    | LConst_0              -- ^ 0x09 - push the long 0 onto the stack
    | LConst_1              -- ^ 0x0a - push the long 1 onto the stack
    | FConst_0              -- ^ 0x0b - push 0.0f on the stack
    | FConst_1              -- ^ 0x0c - push 1.0f on the stack
    | FConst_2              -- ^ 0x0d - push 2.0f on the stack
    | DConst_0              -- ^ 0x0e - push the constant 0.0 onto the stack
    | DConst_1              -- ^ 0x0f - push the constant 1.0 onto the stack

    | BIPush Int8           -- ^ 0x10 - push a byte onto the stack as an integer value
    | SIPush Int16          -- ^ 0x11 - push a short onto the stack

    | SPush Text            -- ^ 0x12 or 0x13 - push a String from constant pool #index onto the stack

    | LdC    Word8          -- ^ 0x12 - push a constant #index from a constant pool (String, int or float) onto the stack
    | LdC_W  Word16         -- ^ 0x13 - push a constant #index from a constant pool (String, int or float) onto the stack
                            --            (wide index is constructed as indexbyte1 << 8 + indexbyte2)
    | LdC2_W Word16         -- ^ 0x14 - push a constant #index from a constant pool (double or long) onto the stack
                            --            (wide index is constructed as indexbyte1 << 8 + indexbyte2)

    | ILoad Word8           -- ^ 0x15 - load an int value from a local variable #index
    | LLoad Word8           -- ^ 0x16 - load a long value from a local variable #index
    | FLoad Word8           -- ^ 0x17 - load a float value from a local variable #index
    | DLoad Word8           -- ^ 0x18 - load a double value from a local variable #index
    | ALoad Word8           -- ^ 0x19 - load a reference onto the stack from a local variable #index

    | ILoad_0               -- ^ 0x1a - load an int value from local variable 0
    | ILoad_1               -- ^ 0x1b - load an int value from local variable 1
    | ILoad_2               -- ^ 0x1c - load an int value from local variable 2
    | ILoad_3               -- ^ 0x1d - load an int value from local variable 3

    | LLoad_0               -- ^ 0x1e - load a long value from a local variable 0
    | LLoad_1               -- ^ 0x1f - load a long value from a local variable 1
    | LLoad_2               -- ^ 0x20 - load a long value from a local variable 2
    | LLoad_3               -- ^ 0x21 - load a long value from a local variable 3

    | FLoad_0               -- ^ 0x22 - load a float value from local variable 0
    | FLoad_1               -- ^ 0x23 - load a float value from local variable 1
    | FLoad_2               -- ^ 0x24 - load a float value from local variable 2
    | FLoad_3               -- ^ 0x25 - load a float value from local variable 3

    | DLoad_0               -- ^ 0x26 - load a double from local variable 0
    | DLoad_1               -- ^ 0x27 - load a double from local variable 1
    | DLoad_2               -- ^ 0x28 - load a double from local variable 2
    | DLoad_3               -- ^ 0x29 - load a double from local variable 3

    | ALoad_0               -- ^ 0x2a - load a reference onto the stack from local variable 0
    | ALoad_1               -- ^ 0x2b - load a reference onto the stack from local variable 1
    | ALoad_2               -- ^ 0x2c - load a reference onto the stack from local variable 2
    | ALoad_3               -- ^ 0x2d - load a reference onto the stack from local variable 3

    | IALoad                -- ^ 0x2e - load an int from an array
    | LALoad                -- ^ 0x2f - load a long from an array
    | FALoad                -- ^ 0x30 - load a float from an array
    | DALoad                -- ^ 0x31 - load a double from an array
    | AALoad                -- ^ 0x32 - load onto the stack a reference from an array
    | BALoad                -- ^ 0x33 - load a byte or Boolean value from an array
    | CALoad                -- ^ 0x34 - load a char from an array
    | SALoad                -- ^ 0x35 - load a short from an array

    | IStore Word8          -- ^ 0x36 - store int value into variable #index
    | LStore Word8          -- ^ 0x37 - store a long value in a local variable #index
    | FStore Word8          -- ^ 0x38 - store a float value into a local variable #index
    | DStore Word8          -- ^ 0x39 - store a double value into a local variable #index
    | AStore Word8          -- ^ 0x3a - store a reference into a local variable #index

    | IStore_0              -- ^ 0x3b - store int value into variable 0
    | IStore_1              -- ^ 0x3c - store int value into variable 1
    | IStore_2              -- ^ 0x3d - store int value into variable 2
    | IStore_3              -- ^ 0x3e - store int value into variable 3

    | LStore_0              -- ^ 0x3f - store a long value in a local variable 0
    | LStore_1              -- ^ 0x40 - store a long value in a local variable 1
    | LStore_2              -- ^ 0x41 - store a long value in a local variable 2
    | LStore_3              -- ^ 0x42 - store a long value in a local variable 3

    | FStore_0              -- ^ 0x43 - store a float value into local variable 0
    | FStore_1              -- ^ 0x44 - store a float value into local variable 1
    | FStore_2              -- ^ 0x45 - store a float value into local variable 2
    | FStore_3              -- ^ 0x46 - store a float value into local variable 3

    | DStore_0              -- ^ 0x47 - store a double into local variable 0
    | DStore_1              -- ^ 0x48 - store a double into local variable 1
    | DStore_2              -- ^ 0x49 - store a double into local variable 2
    | DStore_3              -- ^ 0x4a - store a double into local variable 3

    | AStore_0              -- ^ 0x4b - store a reference into local variable 0
    | AStore_1              -- ^ 0x4c - store a reference into local variable 1
    | AStore_2              -- ^ 0x4d - store a reference into local variable 2
    | AStore_3              -- ^ 0x4e - store a reference into local variable 3

    | IAStore               -- ^ 0x4f - store an int in an array
    | LAStore               -- ^ 0x50 - store a long to an array
    | FAStore               -- ^ 0x51 - store a float in an array
    | DAStore               -- ^ 0x52 - store a double in an array
    | AAStore               -- ^ 0x53 - store a reference in an array
    | BAStore               -- ^ 0x54 - store a byte or Boolean value in an array
    | CAStore               -- ^ 0x55 - store a char intan array
    | SAStore               -- ^ 0x56 - store a short in an array

    | Pop                   -- ^ 0x57 - discard the top value on the stack
    | Pop2                  -- ^ 0x58 - discard the top two values on the stack
                            --            (or one value, if it is a double or long)

    | Dup                   -- ^ 0x59 - duplicate the value on top of the stack
    | Dup_x1                -- ^ 0x5a - insert a copy of the top value into the stack two values from the top.
                            --            (value1 and value2 must not be of the type double or long)
    | Dup_x2                -- ^ 0x5b - insert a copy of the top value into the stack two
                            --            (if value2 is double or long it takes up the entry of value3, too)
                            --          or three values
                            --            (if value2 is neither double nor long)
                            --          from the top

    | Dup2                  -- ^ 0x5c - duplicate top two stack words
                            --            (two values, if value1 is not double nor long;
                            --             a single value, if value1 is double or long)
    | Dup2_x1               -- ^ 0x5d - duplicate two words and insert beneath third word (see explanation above)
    | Dup2_x2               -- ^ 0x5e - duplicate two words and insert beneath fourth word

    | Swap                  -- ^ 0x5f - swaps two top words on the stack
                            --            (note that value1 and value2 must not be double or long)

    | IAdd                  -- ^ 0x60 - add two ints
    | LAdd                  -- ^ 0x61 - add two longs
    | FAdd                  -- ^ 0x62 - add two floats
    | DAdd                  -- ^ 0x63 - add two doubles

    | ISub                  -- ^ 0x64 - subtract two ints
    | LSub                  -- ^ 0x65 - subtract two longs
    | FSub                  -- ^ 0x66 - subtract two floats
    | DSub                  -- ^ 0x67 - subtract two doubles

    | IMul                  -- ^ 0x68 - multiply two integers
    | LMul                  -- ^ 0x69 - multiply two longs
    | FMul                  -- ^ 0x6a - multiply two floats
    | DMul                  -- ^ 0x6b - multiply two doubles

    | IDiv                  -- ^ 0x6c - divide two integers
    | LDiv                  -- ^ 0x6d - divide two longs
    | FDiv                  -- ^ 0x6e - divide two floats
    | DDiv                  -- ^ 0x6f - divide two doubles

    | IRem                  -- ^ 0x70 - remainder of division of two ints
    | LRem                  -- ^ 0x71 - remainder of division of two longs
    | FRem                  -- ^ 0x72 - remainder of division of two floats
    | DRem                  -- ^ 0x73 - remainder of division of two doubles

    | INeg                  -- ^ 0x74 - negate an int
    | LNeg                  -- ^ 0x75 - negate a long
    | FNeg                  -- ^ 0x76 - negate a float
    | DNeg                  -- ^ 0x77 - negate a double

    | IShl                  -- ^ 0x78 - int shift left
    | LShl                  -- ^ 0x79 - bitwise shift left of a long value1 by int value2 positions

    | IShr                  -- ^ 0x7a - int arithmetic shift right
    | LShr                  -- ^ 0x7b - bitwise shift right of a long value1 by int value2 positions

    | IUShr                 -- ^ 0x7c - int logical shift right
    | LUShr                 -- ^ 0x7d - bitwise shift right of a long value1 by int value2 positions, unsigned

    | IAnd                  -- ^ 0x7e - bitwise AND of two ints
    | LAnd                  -- ^ 0x7f - bitwise AND of two longs
    | IOr                   -- ^ 0x80 - bitwise OR of two ints
    | LOr                   -- ^ 0x81 - bitwise OR of two longs
    | IXor                  -- ^ 0x82 - bitwise XOR of two ints
    | LXor                  -- ^ 0x83 - bitwise XOR of two longs

    | IInc Word8 Int8       -- ^ 0x84 - increment local variable #index by signed byte #const

    | I2L                   -- ^ 0x85 - convert an int into a long
    | I2F                   -- ^ 0x86 - convert an int into a float
    | I2D                   -- ^ 0x87 - convert an int into a double

    | L2I                   -- ^ 0x88 - convert a long to a int
    | L2F                   -- ^ 0x89 - convert a long to a float
    | L2D                   -- ^ 0x8a - convert a long to a double

    | F2I                   -- ^ 0x8b - convert a float to an int
    | F2L                   -- ^ 0x8c - convert a float to a long
    | F2D                   -- ^ 0x8d - convert a float to a double

    | D2I                   -- ^ 0x8e - convert a double to an int
    | D2L                   -- ^ 0x8f - convert a double to a long
    | D2F                   -- ^ 0x90 - convert a double to a float

    | I2B                   -- ^ 0x91 - convert an int into a byte
    | I2C                   -- ^ 0x92 - convert an int into a character
    | I2S                   -- ^ 0x93 - convert an int into a short

    | LCmp                  -- ^ 0x94 - compare two longs values
    | FCmpL                 -- ^ 0x95 - compare two floats
    | FCmpG                 -- ^ 0x96 - compare two floats
    | DCmpL                 -- ^ 0x97 - compare two doubles
    | DCmpG                 -- ^ 0x98 - compare two doubles

    | IfEq Int16            -- ^ 0x99 - if value is 0, branch to instruction at #branchoffset
    | IfNe Int16            -- ^ 0x9a - if value is not 0, branch to instruction at #branchoffset
    | IfLt Int16            -- ^ 0x9b - if value is less than 0, branch to instruction at #branchoffset
    | IfGe Int16            -- ^ 0x9c - if value is greater than or equal to 0, branch to instruction at #branchoffset
    | IfGt Int16            -- ^ 0x9d - if value is greater than 0, branch to instruction at #branchoffset
    | IfLe Int16            -- ^ 0x9e - if value is less than or equal to 0, branch to instruction at #branchoffset

    | If_ICmpEq Int16       -- ^ 0x9f - if ints are equal, branch to instruction at #branchoffset
    | If_ICmpNe Int16       -- ^ 0xa0 - if ints are not equal, branch to instruction at #branchoffset
    | If_ICmpLt Int16       -- ^ 0xa1 - if value1 is less than value2, branch to instruction at #branchoffset
    | If_ICmpGe Int16       -- ^ 0xa2 - if value1 is greater than or equal to value2, branch to instruction at #branchoffset
    | If_ICmpGt Int16       -- ^ 0xa3 - if value1 is greater than value2, branch to instruction at #branchoffset
    | If_ICmpLe Int16       -- ^ 0xa4 - if value1 is less than or equal to value2, branch to instruction at #branchoffset

    | If_ACmpEq Int16       -- ^ 0xa5 - if references are equal, branch to instruction at #branchoffset
    | If_ACmpNe Int16       -- ^ 0xa6 - if references are not equal, branch to instruction at #branchoffset

    | Goto Int16            -- ^ 0xa7 - goes to another instruction at #branchoffset
    | JSr  Int16            -- ^ 0xa8 - jump to subroutine at #branchoffset and place the return address on the stack
    | Ret  Word8            -- ^ 0xa9 - continue execution from address taken from a local variable #index
                            --            (the asymmetry with jsr is intentional)

    | TableSwitch           -- ^ 0xaa - continue execution from an address in the table at offset index
    | LookupSwitch          -- ^ 0xab - a target address is looked up from a table using a key and execution
                            --            continues from the instruction at that address

    | IReturn               -- ^ 0xac - return an int
    | LReturn               -- ^ 0xad - return a long
    | FReturn               -- ^ 0xae - return a float
    | DReturn               -- ^ 0xaf - return a double
    | AReturn               -- ^ 0xb0 - return a reference
    | Return                -- ^ 0xb1 - return void

    | GetStatic FieldRef    -- ^ 0xb2 - get static field value of class, where field is identified by #index in constant pool
    | PutStatic FieldRef    -- ^ 0xb3 - set static field value of class, where field is identified by #index in constant pool

    | GetField  Word16      -- ^ 0xb4 - get field value of object, where the field is identified by #index in constant pool
    | PutField  Word16      -- ^ 0xb5 - set field value of object, where the field is identified by #index in constant pool

    | InvokeVirtual	  MethodRef        -- ^ 0xb6 - invoke virtual method identified by #index in constant pool
    | InvokeSpecial	  MethodRef        -- ^ 0xb7 - invoke instance method identified by #index in constant pool
    | InvokeStatic    MethodRef        -- ^ 0xb8 - invoke static method identified by #index in constant pool
    | InvokeInterface MethodRef Word8  -- ^ 0xb9 - invoke interface method identified by #index in constant pool
    | InvokeDynamic   MethodRef        -- ^ 0xba - invoke dynamic method identified by #index in constant pool

    | New       Word16      -- ^ 0xbb - create new object of type identified by #index in constant pool
    | NewArray  Word8       -- ^ 0xbc - create new array with count elements of primitive type identified by #atype
    | ANewArray Word16      -- ^ 0xbd - create new array with count elements of reference type identified by #index in constant pool

    | ArrayLength           -- ^ 0xbe - get the length of an array

    | AThrow                -- ^ 0xbf - throws an error or exception (the stack is cleared, leaving only the Throwable)

    | CheckCast  Word16     -- ^ 0xc0 - casts an object is to a certain type, identified by #index in constant pool
    | InstanceOf Word16     -- ^ 0xc1 - determines if an object is of a certain type, identified by #index in constant pool

    | MonitorEnter          -- ^ 0xc2 - enter monitor for object ("grab the lock" - start of synchronized() section)
    | MonitorExit           -- ^ 0xc3 - exit monitor for object ("release the lock" - end of synchronized() section)

    | Wide                  -- ^ 0xc4 - wide version of load/store/inc

    | MultiANewArray Word16 Word8   -- ^ 0xc5 - create a new array of #dimensions with elements of type #index in constant pool

    | IfNull    Int16      -- ^ 0xc6 - if value is null, branch to instruction at #branchoffset
    | IfNonNull Int16      -- ^ 0xc7 - if value is not null, branch to instruction at #branchoffset

    | Goto_W Int32         -- ^ 0xc8 - goes to another instruction at #branchoffset
    | JSr_W  Int32         -- ^ 0xc9 - jump to subroutine at #branchoffset

    deriving (Eq, Ord, Show, Read)
